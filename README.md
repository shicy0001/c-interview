# c-interview
## C++基础知识
### static关键字的作用（分变量和函数，从作用域和生存周期来回答）
1. 静态函数：表明函数的作用域，该静态函数对其他文件不可见；
2. 静态全局变量：存储在静态区，在程序运行期间存在，只在定义该变量文件中可见，未被初始化的静态全局变量会被默认初始化；
3. 静态局部变量：存储在静态区，作用域是函数体内，在程序运行期间存在，未被初始化的静态局部变量会被默认初始；
4. 类中的静态成员变量：存储在静态区，被该类所有对象共享；
5. 类中的静态成员函数：不能直接引用非静态成员，入参没有this指针。


### C和C++的区别
 1. 设计思想上：C是面向过程，C++是面向对象，C++多了封装、继承、多态这些特性，

 ### C++中的四种cast转换

 1.  static_cast<type-id>(expr)  
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast，把expr转换为type_id类型，但是没有运行时类型检查来保证转换的安全性，它主要有以下用法：  
用于基本数据类型之间的转换  
把空指针转换为目标类型的指针  
用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的  
把任何类型的表达式转换成void类型  

2. const_cat<type-id>(expr)  
const_cast只能改变对象的底层const，除了const 或volatile修饰之外， type_id和expression的类型是一样的  

3. dynamic_cast<type-id>(expr)  
用于将基类的指针或引用安全地转换成派生类的指针或引用。特别适用于以下情况：想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。

4. reinpreter_cast<type-id>(expression)  
几乎什么都可以转，可能会出问题，尽量少用

### 指针和引用的区别  
1. 指针和引用的实现原理一样，引用本质是个常量指针，可以看汇编代码验证；
2. 使用上的区别：指针可以初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；作为参数传递时，指针需要解引用才可以对对象进行操作，引用不需要；指针可以改变指向，但引用本质是指针常量，不可以改变；


### C++中的四个智能指针  
为了更容易、更安全的使用动态内存，标准库提供了智能指针来管理动态对象，智能指针和普通指针的重要区别是它负责自动的释放对象，避免内存泄漏。  
1. auto_ptr(c++98的方案，cpp11已抛弃)

2. shared_ptr  
shared_ptr实现共享式拥有的概念，多个智能指针可以指向相同的对象，使用计数器来表明资源被几个对象共享，当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会通过析构函数自动销毁此对象。

3.  unique_ptr  
unique_ptr实现独占式拥有的概念，，某个时刻只能有一个unique_ptr指向一个给定对象，所以不可以把一个unique_ptr赋值给另一个unique_ptr（除除了作为返回值）。

4. weak_ptr  
不控制所指向对象生存期的智能指针，它指向一由一个shared_ptr管理的对象，将一个weak_ptr绑定到一个shard_ptr不会改变shared_ptr的引用计数。由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock函数。weak_ptr时用来解决shared_ptr相互引用时的死锁问题。


### 什么是野指针  
访问一个已销毁或访问受限的内存区域的指针；
比如：指针被free掉之后没有置为NULL

### 为什么析构函数必须是虚函数？构造函数为什么不能是虚函数？ 
考虑多态的情况，将父类的析构函数设置为虚函数，当释放基类指针时，可以避免内存泄漏。C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。  
如果构造函数是虚函数，就要通过虚函数表指针找到虚函数表然后调用，但此时对象还没有实例化，没有内存空间，就没有虚函数表指针，所以构造函数不能是虚函数。

### 析构的顺序  
派生类的析构->对象成员的析构->基类的析构

### 多态
多态的条件：1.子类重写父类的虚函数；2.通过基类的指针或引用调用虚函数
多态的实现：有虚函数的类都有虚函数表，子类会继承父类的虚函数表，如果子类重写了虚函数，子类的虚函数表中该函数的地址会被替换成子类重写的函数地址，每个对象都有一个虚函数表指针，指向虚函数表，虚函数表指针存储在对象的头部，虚函数表在只读数据段。


### const修饰成员函数的目的  
const修饰成员函数实际修饰的是this指针，保证函数调用不会对对象做更改

### 隐式类型转换  


### C++函数栈空间的最大值  
默认是1M，可以调整

### EXTERN "C"
调用C语言函数需要用到EXTERN C，因为C++支持重载，编译时会做函数名重整，而C语言不会，所以需要EXTERN C做链接指示。


### new/delete与malloc/free的区别是什么  
new/delete是c++关键字，malloc/free是c语言库函数，malloc使用要指明申请空间大小，返回的指针要做强转，new不用指定内存大小，返回的指针不用强转；另外，对于类类型的对象，malloc/free不会调用构造函数和析构函数，new/delete会调用构造函数和析构函数。

### 请说说你了解的RTTI  

### C语言函数压栈的顺序  
从右到左  

### C++中拷贝构造函数的形参能否进行值传递？  
不能。如果可以值传递，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递又要调用拷贝构造函数，如此循环，无法完成拷贝，栈也会满。


### 重载和重写的区别  
重载：函数名相同，形参不同（个数、类型）  
重写：子类继承父类，在子类中重新实现了父类中的函数


### C++类成员的访问权限  
1. public:类内和类外均可访问  
2. protected:类内、子类中可访问
3. private:类内可访问

### C++中struct和class的区别  
默认访问权限和继承权限不一样，struct的默认访问权限和继承权限是public，class的默认访问权限和继承权限是private。

### C++类内可以定义引用数据成员吗？
可以，但是像引用、const成员，必须通过构造函数初始化列表初始化。

### 左值、右值、左值引用、右值引用  
所有的C++表达，不是左值就是右值  
左值(lvalue)：存在于单个表达式之外的对象，所有的变量，包括常变量，都是左值。  
右值(rvalue)：暂时存在的值，存在于表达式之内，出了表达式他就挂了，将亡值。  

### 虚函数和纯虚函数的区别  
虚函数是有实现的，哪怕是空实现，它的作用是为了在子类中被覆盖，实现多态；  
纯虚函数只是接口，它的实现必须留到子类中。声明了纯虚函数的类不能被实例化。

### 一个空类有哪些函数？  
有六个：默认构造、拷贝构造、析构函数、赋值运算符、两个取址运算符(其中一个是const版本)


### volatile关键字的作用和使用场景？  
在C/C++中，volatile 关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，因此编译器在代码编译时就不会对该变量进行某些激进的优化，故而编译生成的程序在每次存储或读取该变量时，都会直接从内存地址中读取数据。相反，如果该变量没有使用 volatile 关键字进行声明，则编译器可能会优化读取和存储操作，可能暂时使用寄存器中该变量的值，而如果这个变量由别的程序（线程）更新了的话，就会出现（内存中与寄存器中的）变量值不一致的现象。

对于多线程编程而言，在临界区内部，可以通过互斥锁（mutex）保证只有一个线程可以访问该临界区的内容，因此临界区内的变量不需要是 volatile 的；而在临界区外部，被多个线程访问的变量应声明为 volatile 的，这也符合了 volatile 的原意：防止编译器缓存（cache）了被多个线程并发用到的变量。


### 内存对齐的原则  
1).数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。

2).结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。

3).收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。

4).sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。

## STL容器  

### STL的组成部分  
STL有六大组件：  
1. 容器(container)：各种数据结构，如vector,list,deque,set,map,用来存放数据。从实现的角度来看，STL容器是一种class template。
2. 算法(algorithms)：各种常用算法如sort,search,copy,erase...从实现的角度来看，STL算法是一种function template。
3. 迭代器(iterators)：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，从实现的角度，迭代器是一种将operator*,operator->,operator++,operator--等指针相关操作予以重载的class template。
4. 仿函数(functors)：行为类似函数，可作为算法的某种策略
5. 配接器(adapters)：一种用来修饰容器或仿函数或迭代器接口的东西
6. 配置器(allocators)：负责空间的配置和管理。  

六大组件的相互关系:container通过allocator获取数据存储空间，algorithm通过iterator存取container内容，functor可以协助algorithm完成不同的策略变化，adapter可以修饰或套接functor。

### 顺序容器vector和list的区别和应用  
1. vector底层实现是连续存储的动态数组，在堆上分配空间，vector增加元素时，如果还有空间，直接添加到末尾，然后调整迭代器，如果没有空然后调整迭代器，如果没有空间，则会重新分配原有元素个数的两倍空间，然后将元素复制到新空间，释放原空间，之前的迭代器会失效；list底层实现是环状的双向链表，在堆上分配空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间；  
2. 特点  
vector:访问快，在末尾插入和删除快，在中间插入和删除慢，适用于经常随机访问，不经常对非尾节点进行插入和删除  
list:访问慢，插入和删除快，适用于经常插入和删除大量数据 

### 关联容器map和set  
map和set的底层实现都是红黑树。  
区别：  
1. map中的元素是key-value(关键字-值)，set的元素是key(关键字);
2. set不允许修改关键字的值，map可以修改value，但不允许修改key;
3. map支持下标操作，set不支持下标操作。但map下标操作要慎用，因为若key不存在会插入新元素，所以如果能用find解决尽可能用find。

### 迭代器迭代器失效  
#### 向容器添加元素  
1. 对于vector和string，如果存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效，如果存储空间未重新分配，插入元素之前的迭代器、指针、引用不会失效，但插入元素之后的迭代器、指针、引用会失效；  
2. 对于deque来说，在首尾位置之外的任何位置插入元素都会导致迭代器、指针、引用失效，在首尾位置插入，已存在元素的迭代器、指针、引用不会失效；  
3. 对于list来说，插入元素不会导致迭代器、指针、引用失效；  
4. 对于map和set来说，不会失效。
 #### 向容器删除元素  
 1. 对于vector和string，删除元素之前的迭代器、指针、引用不会失效，之后的会失效；  
 2. 对于list来说，除删除元素之外的其他元素的迭代器、指针、引用不会失效；  
 3. 对于map和set来说，除了被删除结点外，其他的指针、引用、迭代器不会失效。

 ### 容器的底层数据结构  
 vector：数组
 list：链表
 set/map：红黑树
 hashtable:散列表（底层数据结构是vector）
 unordered_map：散列表





## 计算机网络  
### TCP建立和断开连接的过程  
三次握手的目的不仅在于让通信双方了解一个连接正在建立，更重要的是交换双方的初始化序列号ISN，序列号可以保证应用层收到的数据不会乱序，因为TCP根据序列号拼接数据。  
#### 三次握手  
1. 客户端向服务端发送SYN报文段，包含客户端的初始化序列号x
2. 服务端向客户端发送自己的SYN报文，包含服务端的初始化序列号y，同时
为了确认客户端的SYN，服务端将x的数值加1作为ACK值
3. 客户端确认服务端的SYN，将y+1作为ACK值返回。   

TCP是全双工的，两个方向上都有数据传输，因此每个方向都需要单独进行关闭，当一方完成数据传送时，发送FIN报文段终止这一方向上的连接
#### 四次挥手  
1. 主动关闭者发送一个FIN报文段，包含自己当前的序列号K，还包含一个ACK段确认最近一次收到的数据  
2. 被动关闭者将K+1作为ACK值返回  
3. 被动关闭者发送自己的FIN，包含自己当前的序列号L
4. 主动关闭者将L+1作为ACK值返回。 

### 三次握手和四次挥手的原因  


### OSI七层模型和TCP/IP四层模型，每层列举2个协议
#### OSI七层模型  
1. 物理层：
2. 数据链路层： 
3. 网络层： 
4. 传输层：
5. 会话层：
6. 表示层；
7. 应用层：
#### TCP/IP四层模型  
1. 网络接口层：MAC,VLAN
2. 网络层:IP,ARP,ICMP
3. 传输层:TCP,UDP
4. 应用层:HTTP,DNS,SMTP  

### 搜索baidu，会用到计算机网络中的什么层？每层是干什么的  

### 请你说说TCP的拥塞控制

### TCP如何保证可靠性  
1. 确认应答、超时重传、序列号  
接收方收到数据会给一个确认应答，表示该数据段已收到，并且确认序号是接收方希望收到的下一个数据段；如果发送方迟迟没有收到确认应答，可能是数据或者确认应答丢了，发送方会进行重传。 
2. 窗口控制与快速重传  
利用窗口控制来提高传输速度，在一个窗口大小内，不用一定要等到应答才能发送下一个数据段（个人理解翻译成大白话就是：这个窗口内的数据可以一次性全发了）。  
重传有两种方式：超时重传（基于时间）和快速重传（基于数据）。超时重传是发送方等待一个超时时间，如果收到确认应答就重传，超时时间通常是2*RTT+偏差值。快速重传是，发送方如果收到三个相同的确认应答则重传。  
3. 拥塞控制  
如果把窗口定义的很大，发送方连续发送大量的数据，可能会造成网络拥堵，TCP为了防止这种情况而进行拥塞控制。发送放维持一个叫拥塞窗口cwnd(congestion window)的状态变量，发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。   
慢启动（刚加入网络的连接要一点一点提速）：一开始窗口大小初始化为1，每收到一个ACK，窗口大小加1，每当过了一个RTT，窗口大小*2。当窗口大小大于阈值，进入拥塞避免。  
拥塞避免：设置慢启动阈值，当拥塞窗口大小达到阈值，变成加法增加。当出现网络拥塞（三个重复的ACK或超时），会调整阈值和窗口大小。

### 搜索baidu会用到计算机网络中的什么层？每层是干什么的？  
浏览器中输入URL，处理过程：浏览器要将URL解析为IP地址，解析域名需要用到DNS协议，主机首先会查询DNS的缓存，如果没有就给本地DNS发送查询请求，DNS服务器基于UDP，所以会用到UDP协议。得到IP地址后，浏览器就要与服务器建议一个HTTP连接，因此要用到HTTP协议，HTTP生成GET请求报文，将该报文传给TCP层处理，所以用到TCP协议，TCP把数据包发送给IP层，用到IP协议，得到目的IP地址的物理地址，需要ARP协议。  
DNS/HTTP(HTTPS)属于应用层，TCP/UDP属于传输层，IP/ARP属于网络层，再往下是数据链路层和物理层。  

### TCP和UDP的区别以及各自适用的场景  
1. 连接。TCP是面向连接的传输层协议，传输数据之前必须先建立好连接。UDP无连接。  
2. 服务对象。TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一、一对多、多对一、多对多的交互通信。
3. 可靠性。TCP是可靠交付，UDP不保证可靠交付。  
4. 拥塞控制、流量控制。TCP有拥塞控制和流量控制，UPD没有。
5. 报文长度。TCP是动态报文长度，TCP报文长度根据当前网络拥塞情况和接收方的接收能力决定。UDP不合并，不拆分，保留上层传下来报文的边界。  
6. 首部开销。TCP首部开销大，首部20个字节，UDP首部开销小，8字节。
7. 各自适用的场景：TCP可靠但速度慢，UDP不可靠但速度快，应当根据通信数据的要求决定协议，若可靠性优先于实时性，应该选择TCP（如文件传输），反之选择UDP（如视频传输、实时通信）。  

### 网络编程中服务端和客户端主要用到哪些函数？  
#### 基于TCP
1. 服务器端：socket()->bind()->listen()->accept()->recv()->close()
2. 客户端：socket()->connect()->send()->close()

#### 基于UDP  
1. 服务器端：socket()->sendto()/recvfrom()->close()
2. 客户端：socket()->sendto()/recvfrom()->close()

### 网络编程模型


## 数据库  
### 添加索引的优缺点和添加索引的原则  
数据库索引是为了增加查询速度而对表字段增加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。
1. 添加索引的优点：大大加快检索的速度
2. 添加索引的缺点：索引占物理空间；当对表数据进行维护时，索引也要动态的维护，这样就降低了数据维护的速度。
3. 添加索引的原则：在查询中很少使用或者参考的列不应该创建索引；只有很少数据值的列也不应该增加索引；定义为text、image和bit数据类型的列不应该增加索引；当修改性能远远大于检索性能时，不应该创建索引。


### 数据库事务以及四个特性  
事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。
1. 原子性：事务包含的所有操作要么全部成功，要么全部失败回滚；
2. 一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态；
3. 隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离；
4. 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。


## 操作系统
### 进程和线程的区别  
1. 一个线程只能属于一个进程，一个进程可以有多个线程，但至少有一个线程，线程依赖于进程而存在；
1. 进程是资源分配的最小单位，线程是CPU调度的最小单位；
2. 每个进程拥有独立的内存空间，而多个线程共享进程的内存。同一进程中的多个线程共享该进程的代码段、数据段、堆，每个线程有自己的栈，用来存放局部变量；
3. 系统开销：由于在创建和销毁进程时，系统要为其分配和回收资源，因此开销显著大于创建和销毁线程的开销，类似的，进程切换的开销也远远大于线程切换的开销；
4. 通信：由于线程共享同意地址空间，所以线程间通信也比较容易；
5. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉

### 进程间通信的方式  
进程间通信的方式主要包括：管道、系统IPC(消息队列、信号、信号量、共享内存等)、套接字socket  

### 线程间同步的方式  
临界区、互斥量、信号量、事件（信号）


## 网络编程


## 算法
### 排序  


